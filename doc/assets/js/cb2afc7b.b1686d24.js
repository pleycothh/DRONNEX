"use strict";(self.webpackChunkdocs_site=self.webpackChunkdocs_site||[]).push([[2689],{8453:(r,n,e)=>{e.d(n,{R:()=>d,x:()=>a});var o=e(6540);const t={},i=o.createContext(t);function d(r){const n=o.useContext(i);return o.useMemo((function(){return"function"==typeof r?r(n):{...n,...r}}),[n,r])}function a(r){let n;return n=r.disableParentContext?"function"==typeof r.components?r.components(t):r.components||t:d(r.components),o.createElement(i.Provider,{value:n},r.children)}},9583:(r,n,e)=>{e.r(n),e.d(n,{assets:()=>l,contentTitle:()=>a,default:()=>u,frontMatter:()=>d,metadata:()=>o,toc:()=>c});const o=JSON.parse('{"id":"project/foc-balance-bot","title":"FOC balance bot","description":"Introduction","source":"@site/docs/project/foc-balance-bot.md","sourceDirName":"project","slug":"/project/foc-balance-bot","permalink":"/doc/docs/project/foc-balance-bot","draft":false,"unlisted":false,"editUrl":"https://github.com/pleycothh/DRONNEX/tree/main/docs-site/docs/project/foc-balance-bot.md","tags":[],"version":"current","sidebarPosition":2,"frontMatter":{"sidebar_position":2},"sidebar":"tutorialSidebar","previous":{"title":"3D printed VTOL","permalink":"/doc/docs/project/3d-printed-vtol"},"next":{"title":"AI Drone (Chinese)","permalink":"/doc/docs/project/ai-drone-cn"}}');var t=e(4848),i=e(8453);const d={sidebar_position:2},a="FOC balance bot",l={},c=[{value:"Introduction",id:"introduction",level:2},{value:"Prerequirement",id:"prerequirement",level:2}];function s(r){const n={code:"code",h1:"h1",h2:"h2",header:"header",p:"p",pre:"pre",strong:"strong",...(0,i.R)(),...r.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"foc-balance-bot",children:"FOC balance bot"})}),"\n",(0,t.jsx)(n.h2,{id:"introduction",children:"Introduction"}),"\n",(0,t.jsx)(n.p,{children:"TODO"}),"\n",(0,t.jsx)(n.h2,{id:"prerequirement",children:"Prerequirement"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Code:"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:'#include <SimpleFOC.h>\r\n\r\n// BLDCMotor(pole pair number, phase resistance (optional) );\r\nBLDCMotor motorL = BLDCMotor(7);\r\nBLDCDriver3PWM driverL = BLDCDriver3PWM(40, 41, 42, 12, NOT_SET, NOT_SET);\r\n// Encoder Left\r\nEncoder encoderL =  Encoder(15, 16, 1024, 17); // 15, 16, 1024, 17\r\nvoid doAL(){encoderL.handleA();}\r\nvoid doBL(){encoderL.handleB();}\r\nvoid doIndexL(){encoderL.handleIndex();}\r\n\r\n\r\nBLDCMotor motorR = BLDCMotor(7);\r\nBLDCDriver3PWM driverR = BLDCDriver3PWM(35, 36, 37, 38, NOT_SET, NOT_SET);\r\n// Encoder Right\r\nEncoder encoderR =  Encoder(4, 5, 1024, 6);\r\n// interrupt routine initialization\r\nvoid doAR(){encoderR.handleA();}\r\nvoid doBR(){encoderR.handleB();}\r\nvoid doIndexR(){encoderR.handleIndex();}\r\n\r\n\r\n/*instantiate the commander\r\nCommander command = Commander(Serial);\r\nvoid doTarget(char* cmd) { command.scalar(&motorL.target, cmd); }\r\nvoid doLimit(char* cmd) { command.scalar(&motorL.voltage_limit, cmd); }\r\n*/\r\n\r\nvoid setup() {\r\n  //--------------------------------------------  use monitoring with serial \r\n  Serial.begin(115200);\r\n  SimpleFOCDebug::enable(&Serial);\r\n\r\n  //----------------------------- Left\r\n  // enable/disable quadrature mode\r\n  encoderL.quadrature = Quadrature::ON;\r\n  // check if you need internal pullups\r\n  encoderL.pullup = Pullup::USE_EXTERN;\r\n  // initialize encoder hardware\r\n  encoderL.init();\r\n  // hardware interrupt enable\r\n  encoderL.enableInterrupts(doAL, doBL, doIndexL);\r\n  motorL.linkSensor(&encoderL);\r\n  Serial.println("Encoder Left ready");\r\n  _delay(1000);\r\n\r\n  // ------------ driver Left\r\n  // power supply voltage [V]\r\n  driverL.voltage_power_supply = 5;\r\n  // Max DC voltage allowed - default voltage_power_supply\r\n  driverL.voltage_limit = 2;\r\n\r\n  // driver init\r\n  if (!driverL.init()){\r\n    Serial.println("driver L init failed!");\r\n    return;\r\n  }\r\n\r\n  motorL.linkDriver(&driverL);\r\n  // enable driver\r\n  //driverL.enable();\r\n  Serial.println("Driver L ready!");\r\n  _delay(1000);\r\n// ---------------------------- motor Left\r\n  // aligning voltage\r\n  motorL.voltage_sensor_align = 5;\r\n\r\n  // set motion control loop to be used\r\n  motorL.torque_controller = TorqueControlType::voltage;\r\n  motorL.controller = MotionControlType::torque;\r\n\r\n  // comment out if not needed\r\n  motorL.useMonitoring(Serial);\r\n\r\n  // initialize motor\r\n  if(!motorL.init()){\r\n    Serial.println("Motor init failed!");\r\n    return;\r\n  }\r\n  // align sensor and start FOC\r\n  if(!motorL.initFOC()){\r\n    Serial.println("FOC init failed!");\r\n    return;\r\n  }\r\n\r\n  // set the initial motor target\r\n  motorL.target = 2; // Volts \r\n\r\n  // add target command M\r\n  //command.add(\'M\',"Motor");\r\n\r\n  Serial.println(F("Motor ready."));\r\n  Serial.println(F("Set the target using serial terminal and command M:"));\r\n  _delay(1000);\r\n\r\n\r\n  //--------------  Right\r\n  // enable/disable quadrature mode\r\n  encoderR.quadrature = Quadrature::ON;\r\n  // check if you need internal pullups\r\n  encoderR.pullup = Pullup::USE_EXTERN;\r\n  // initialize encoder hardware\r\n  encoderR.init();\r\n  // hardware interrupt enable\r\n  encoderR.enableInterrupts(doAR, doBR, doIndexR);\r\n  motorR.linkSensor(&encoderR);\r\n  Serial.println("Encoder Right ready");\r\n  _delay(1000);\r\n  // --------------------------------- Encoder ends\r\n\r\n  // ------------ driver Right\r\n\r\n    // power supply voltage [V]\r\n  driverR.voltage_power_supply = 5;\r\n  // Max DC voltage allowed - default voltage_power_supply\r\n  driverR.voltage_limit = 2;\r\n\r\n  // driver init\r\n  if (!driverR.init()){\r\n    Serial.println("Driver R init failed!");\r\n    return;\r\n  }\r\n\r\n  // enable driver 2\r\n  driverR.enable();\r\n  Serial.println("Driver R ready!");\r\n  _delay(1000);\r\n  // ------------------------------Driver ends\r\n  // link driver\r\n  motorR.linkDriver(&driverR);\r\n  _delay(1000);\r\n\r\n\r\n}\r\n\r\nvoid loop() {\r\n  // IMPORTANT - call as frequently as possible\r\n  // update the sensor values \r\n // encoderL.update();\r\n  //encoderR.update();\r\n  // display the angle and the angular velocity to the terminal\r\n // Serial.print(encoderL.getAngle());\r\n // Serial.print("\\t");\r\n//  Serial.println(encoderR.getAngle());\r\n\r\n  // main FOC algorithm function\r\n  motorR.loopFOC();\r\n\r\n  // Motion control function\r\n  motorR.move();\r\n\r\n  // user communication\r\n // command.run();\r\n}\r\n\n'})})]})}function u(r={}){const{wrapper:n}={...(0,i.R)(),...r.components};return n?(0,t.jsx)(n,{...r,children:(0,t.jsx)(s,{...r})}):s(r)}}}]);